---
description: Regole specifiche per main.py - codice sorgente principale R-Converter PRO
globs: "main.py"
alwaysApply: false
---

# R-Converter PRO - Regole per main.py

## Struttura del File (~3300-3500 righe)

1. **Imports, logging, costanti** (top)
   - Logging: %LOCALAPPDATA%\R-Converter\r_converter.log (mai nella cartella exe)
   - cv2 try/except: VIDEO_SUPPORT=True/False
   - IMAGE_FORMATS, VIDEO_FORMATS (set O(1)), RESOLUTION_PRESETS, HANDLE_*
   - HZ_PRESETS: [25, 30, 50, 60]

2. **Dati broadcast** (dopo imports)
   - LED_WALL_SPECS: dict con i 6 preset validati su hardware reale
   - FILTER_PROFILES: FilterConfig per ogni LED wall
   - VIDEO_PROFILES_BASE: VideoConfig per ogni codec (DNxHR SQ/HQ/HQX, HAP, HAP Q, ProRes 422, H.264, H.265)
   - AUDIO_PROFILES: AudioConfig (PCM 16, PCM 24, AAC 320)
   - SOFTWARE_TARGETS: mapping software -> codec ottimale per quality tier

3. **Classi dati** (dataclass-like con dict)
   - LEDWallSpec: name, brand, receiving_card, driver_ic, pixel_pitch_mm, quality_tier, gray_depth, scan_type, scan_ratio, gamma, refresh_hz, input_signal_hz, width_px, height_px
   - FilterConfig: deband_threshold, deband_grain, dither_type, dither_scale, black_level, white_level, denoise_strength, sharpen_amount, bilateral_sigma_s, bilateral_sigma_r
   - VideoConfig: codec, profile, level, format_name, pixel_format, container, bitrate_mode, bitrate_1080p_mbps, bitrate_4k_mbps, gop_size, b_frames, preset, framerate
   - AudioConfig: codec, sample_rate, bit_depth, channels, bitrate_kbps
   - ExportProfile: combinazione di video + audio + filters + led_wall + software

4. **ImageLayer** (classe dati layer)
   - Usa `__slots__` per efficienza memoria
   - Cache trasformazioni: (rotation, flip_h, flip_v) + cache zoom
   - get_transformed_image(zoom=X) con cache per pan fluido
   - cleanup() per rilascio risorse

5. **RConverter** (classe principale GUI)
   - `__init__`: variabili stato (incluse PRO: led_wall_var, software_target_var, output_hz, proc_*, ffmpeg_path)
   - `setup_style`: tema dark blue con palette definita
   - `create_widgets`: layout 3 colonne (left scrollabile / canvas / right scrollabile PRO)
   - `create_left_panel`: INVARIATO rispetto a versione Lite
   - `create_canvas_panel`: INVARIATO rispetto a versione Lite
   - `create_right_panel`: RISCRITTO con 7 sezioni PRO (scrollabile)
   - Layer management: load_image, load_video, remove, move, duplicate
   - Canvas rendering: create_composite_image con target_size, riuso oggetti canvas
   - **PRO callbacks**: on_led_wall_change, on_software_change, on_hz_change, update_export_summary
   - **PRO preset**: save_custom_preset, load_custom_preset, import_led_config, load_saved_presets
   - **PRO processing**: _process_image_pro (pipeline Pillow+OpenCV), _build_ffmpeg_command
   - **PRO export**: export_project, _do_export_project (thread), _run_ffmpeg

6. **main()** - Entry point

## Pattern da Seguire

### Pannello destro PRO - 7 sezioni (in ordine)
1. Dimensioni Output + Hz (dropdown Hz aggiunto sotto W/H)
2. Sfondo (griglia colori - invariato)
3. LED Wall / Receiver Card (dropdown 6 preset + custom + import)
4. Software Target (dropdown 5 opzioni)
5. Processing Pre-Export (4 checkbox + slider intensita)
6. Riepilogo Export (auto-aggiornante, read-only)
7. Export Composito (pulsante + progress bar + stato)

### Dropdown a cascata - Regola di aggiornamento
Ogni cambio di LED Wall, Software o Hz deve chiamare `update_export_summary()` che:
1. Legge le 3 selezioni correnti
2. Calcola il profilo export ottimale (get_current_export_profile)
3. Aggiorna il pannello Riepilogo con codec, bitrate, audio, FPS, filtri

### Aggiungere un nuovo preset LED wall
1. Aggiungere entry in LED_WALL_SPECS con tutti i campi
2. Aggiungere entry corrispondente in FILTER_PROFILES
3. Il software target determina automaticamente il codec tramite la matrice quality_tier x software

### Export broadcast - Pipeline
```
Per ogni layer:
  1. Resize alla risoluzione output (Lanczos up, Lanczos down)
  2. Deband (se checkbox attivo): numpy gradient threshold + grain
  3. Color Levels: numpy clip + remap (black_level, white_level)
  4. Bilateral Filter (se checkbox attivo): cv2.bilateralFilter(d=5)
  5. Sharpen: PIL UnsharpMask adattivo
  6. Dither Bayer: ordered 8x8 pattern (anti-banding LED wall 13-14 bit)

Compositing:
  7. Paste tutti i layer processati su canvas output
  8. Conversione colore finale (Rec.709 SDR)
  9. _apply_image_processing() sul composito (immagine E video)

Encoding (solo video):
  10. FFmpeg con color metadata bt709, HAP snappy+chunks, H.264/H.265 CBR
  11. Codec/container dal software target
  12. Audio dal quality tier
```

### Export in thread separato
```python
def export_project(self):
    # Validazione nel main thread
    if not self.layers:
        return
    filepath = filedialog.asksaveasfilename(...)
    if not filepath:
        return
    self.progress.start()
    thread = threading.Thread(target=self._do_export_project, args=(filepath,), daemon=True)
    thread.start()

def _do_export_project(self, filepath):
    try:
        profile = self.get_current_export_profile()
        # Snapshot variabili (thread-safe)
        output_w = self.output_width.get()
        # ... processing + compositing + encoding ...
        self.root.after(0, lambda: self.progress.stop())
        self.root.after(0, lambda: messagebox.showinfo("Successo", "..."))
    except Exception as ex:
        logger.error(f"Errore export: {ex}")
        self.root.after(0, lambda: self.progress.stop())
        self.root.after(0, lambda err=str(ex): messagebox.showerror("Errore", err))
```

### FFmpeg - Regole critiche
- Cercare ffmpeg nel PATH, poi in cartelle note (C:\ffmpeg\bin, %PROGRAMFILES%\ffmpeg\bin)
- Se non trovato: disabilitare export video, abilitare solo export immagine
- Progress: parsare stderr (`time=HH:MM:SS.ms`) per percentuale
- Timeout: 30 minuti max per singolo file, poi kill
- Errori: catturare stderr completo, loggare, mostrare messaggio utente comprensibile

### Filtri broadcast - Parametri calcolati
- deband threshold: valore dal preset LED, normalizzato per FFmpeg (intero 0-255 o float 0-1 a seconda della versione)
- denoise (hqdn3d): luma = int(4 * denoise_strength), chroma = int(3 * denoise_strength)
- color levels: black = black_level/255, white = white_level/255
- sharpen (unsharp): amount dal preset, raggio 3, threshold adattivo
- bilateral: sigmaS e sigmaR dal preset LED
- dither: tipo bayer con scala dal preset, applicato solo su conversione pixel format

## Palette Colori (invariata + nuovi stili)
```python
bg_color      = "#0a1929"   # Sfondo principale
bg_secondary  = "#132f4c"   # Sfondo secondario
bg_tertiary   = "#1a3a5c"   # Hover
fg_color      = "#e3f2fd"   # Testo primario
fg_secondary  = "#90caf9"   # Testo secondario
accent_color  = "#29b6f6"   # Accento cyan
success_color = "#66bb6a"   # Verde export
video_color   = "#7c4dff"   # Viola export video
border_color  = "#1e4976"   # Bordi
broadcast_color = "#ff6f00" # Arancio per sezione broadcast/LED

# Sezioni pannello sinistro (invariate)
layers    = "#1a365d" / "#3182ce"
transform = "#0f2840" / "#1e88e5"
size      = "#1e4a3d" / "#26a69a"
fit       = "#2d1f47" / "#7c4dff"
mirror    = "#3d2a1f" / "#ff7043"

# Sezioni pannello destro PRO (nuove)
ledwall   = "#1a2f1a" / "#4caf50"   # Verde scuro / bordo verde (hardware)
software  = "#2a1a3d" / "#9c27b0"   # Viola scuro / bordo viola (software)
processing= "#3d2a0a" / "#ff9800"   # Ambra scuro / bordo ambra (processing)
summary   = "#0a2a3d" / "#00bcd4"   # Cyan scuro / bordo cyan (riepilogo)
export_pro= "#3d0a0a" / "#f44336"   # Rosso scuro / bordo rosso (export)
```
